#!/bin/sh

# Helpers to work with xrandr --verbose output. Every public function accepts an
# optional trailing argument containing the full verbose text; when omitted the
# command invokes xrandr itself so standalone calls see live state.

xr_resolve_verbose() {
	if [ $# -gt 0 ] && [ -n "$1" ]; then
		printf '%s' "$1"
		return 0
	fi

	xrandr --verbose 2>/dev/null
}

xr_display_names() {
	verbose="$(xr_resolve_verbose "${1-}")" || return 1

	printf '%s' "$verbose" | awk '
		/^[^[:space:]]+ (dis)?connected/ { print $1 }
	'
}

xr_display_state() {
	display="$1"
	[ -n "$display" ] || return 1

	verbose="$(xr_resolve_verbose "${2-}")" || return 1

	printf '%s' "$verbose" | awk -v display="$display" '
		/^[^[:space:]]+ (dis)?connected/ {
			if ($1 == display) {
				if ($2 == "connected") {
					print "connected"
				} else {
					print "disconnected"
				}
				found = 1
				exit
			}
		}
		END { if (!found) exit 1 }
	'
}

xr_display_state_map() {
	verbose="$(xr_resolve_verbose "${1-}")" || return 1

	xr_display_names "$verbose" | while IFS= read -r display; do
		state="$(xr_display_state "$display" "$verbose" 2>/dev/null)" || state=""
		printf '%s=%s\n' "$display" "$state"
	done
}

xr_display_section() {
	display="$1"
	[ -n "$display" ] || return 1

	verbose="$(xr_resolve_verbose "${2-}")" || return 1

	printf '%s' "$verbose" | awk -v display="$display" '
		/^[^[:space:]]+ (dis)?connected/ {
			if (found && $1 != display) {
				exit
			}
			if ($1 == display) {
				found = 1
			}
		}
		found { print }
	'
}

xr_escape_multiline() {
	sed -e 's/\\/\\\\/g' -e ':a' -e 'N' -e '$!ba' -e 's/\n/\\n/g'
}

xr_display_section_map() {
	verbose="$(xr_resolve_verbose "${1-}")" || return 1

	xr_display_names "$verbose" | while IFS= read -r display; do
		section="$(xr_display_section "$display" "$verbose" 2>/dev/null)" || section=""
		if [ -n "$section" ]; then
			escaped="$(printf '%s' "$section" | xr_escape_multiline)"
		else
			escaped=""
		fi
		printf '%s=%s\n' "$display" "$escaped"
	done
}

xr_display_edid() {
	display="$1"
	[ -n "$display" ] || return 1

	section="$(xr_display_section "$display" "${2-}")" || return 1
	[ -n "$section" ] || return 1

	code="$(printf '%s\n' "$section" | awk '
		/^[[:space:]]*EDID:/ { capture = 1; next }
		capture {
			if ($0 ~ /^[[:space:]]*[0-9a-fA-F]/) {
				gsub(/[[:space:]]/, "", $0)
				printf "%s", $0
			} else {
				exit
			}
		}
	')"

	[ -n "$code" ] || return 1

	printf '%s\n' "$code"
}

xr_decode_edid_hex() {
	hex="$1"
	[ -n "$hex" ] || return 1

	printf '%b' "$(printf '%s' "$hex" | sed 's/../\\x&/g')" | edid-decode 2>/dev/null
}

xr_display_edid_decoded() {
	display="$1"
	[ -n "$display" ] || return 1

	edid_hex="$(xr_display_edid "$display" "${2-}")" || return 1

	xr_decode_edid_hex "$edid_hex"
}

xr_extract_serial_from_decoded() {
	awk -F"'" '
		/Display Product Serial Number:/ {
			gsub(/[[:space:]]+$/, "", $2)
			print $2
			exit
		}
	'
}

xr_display_serial() {
	display="$1"
	[ -n "$display" ] || return 1

	decoded="$(xr_display_edid_decoded "$display" "${2-}" 2>/dev/null)" || return 1

	serial="$(printf '%s\n' "$decoded" | xr_extract_serial_from_decoded)"

	if [ -z "$serial" ]; then
		serial="$(printf '%s\n' "$decoded" | awk -F': ' '
			/Serial Number:/ {
				gsub(/[[:space:]]+$/, "", $2)
				print $2
				exit
			}
		')"
	fi

	if [ -z "$serial" ]; then
		serial="$(printf '%s\n' "$decoded" | awk -F"'" '
			/Alphanumeric Data String:/ { value = $2 }
			END {
				if (value != "") {
					gsub(/^[[:space:]]+|[[:space:]]+$/, "", value)
					print value
				}
			}
		')"
	fi

	[ -n "$serial" ] || return 1

	printf '%s\n' "$serial"
}

xr_display_serial_map() {
	verbose="$(xr_resolve_verbose "${1-}")" || return 1

	xr_display_names "$verbose" | while IFS= read -r display; do
		serial="$(xr_display_serial "$display" "$verbose" 2>/dev/null)" || serial=""
		printf '%s=%s\n' "$display" "$serial"
	done
}

xr_cli_usage() {
	cat <<'EOF'
Usage: xrandr-display-map <command> [args]

Commands:
  state <display>         Print connection state for a display
  state-map               Print map of display=state for all displays
  section <display>       Print the xrandr --verbose section for a display
  section-map             Print display=section map (section newlines escaped as \n)
  edid <display>          Print EDID hex string for a display
  edid-decoded <display>  Print decoded EDID for a display
  serial <display>        Print serial number for a display
  serial-map              Print display=serial map (blank value if unavailable)
  names                   List display names detected in xrandr --verbose output
  help                    Show this message
EOF
}

xr_cli() {
	cmd="$1"
	case "$cmd" in
		state)
			shift
			xr_display_state "$1"
			;;
		state-map)
			xr_display_state_map
			;;
		section)
			shift
			xr_display_section "$1"
			;;
		section-map)
			xr_display_section_map
			;;
		edid)
			shift
			xr_display_edid "$1"
			;;
		edid-decoded)
			shift
			xr_display_edid_decoded "$1"
			;;
		serial)
			shift
			xr_display_serial "$1"
			;;
		serial-map)
			xr_display_serial_map
			;;
		names)
			xr_display_names
			;;
		help|"")
			xr_cli_usage
			;;
		*)
			xr_cli_usage 1>&2
			exit 1
			;;
	esac
}

if [ "${1-}" = "--lib" ]; then
	shift
	if ! return 0 2>/dev/null; then
		exit 0
	fi
fi

xr_cli "$@"
